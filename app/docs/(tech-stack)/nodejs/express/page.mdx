import { FileTree } from "nextra/components";
import { Callout, Steps } from "nextra/components";

# Express.js

เอกสารนี้อธิบายขั้นตอนการ Deploy เว็บแอปพลิเคชัน **Node.js (Express)** โดยใช้ **Docker Compose**
เหมาะสำหรับการใช้งานภายในเครือข่าย **LAN** การ Deploy Express ด้วย Docker จะใช้ **Node.js Image**
เพื่อประมวลผลแอปพลิเคชันและให้บริการผ่านโปรโตคอล HTTP

---

## Project Structure

โครงสร้างไฟล์ของโปรเจกต์ Express ที่ใช้ร่วมกับ Docker Compose ควรแยกส่วนของ Source Code และไฟล์กำหนดค่า (Configuration) อย่างชัดเจน เพื่อให้ง่ายต่อการดูแลและแก้ไขในอนาคต

<FileTree>
  <FileTree.Folder name="project" defaultOpen>
    <FileTree.File name="docker-compose.yml" />
    <FileTree.Folder name="app" defaultOpen>
      <FileTree.File name="index.js" />
      <FileTree.File name="index.html" />
      <FileTree.File name="package.json" />
      <FileTree.File name="__more" />
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

โครงสร้างดังกล่าวแยกหน้าที่ของไฟล์อย่างชัดเจน ไฟล์ `docker-compose.yml`
ใช้สำหรับกำหนดการทำงานของ Container โฟลเดอร์ `app` ใช้เก็บ Source Code และ Dependencies ทั้งหมดที่ Node.js จะนำไปประมวลผล

## Application Components

### Package Configuration

ไฟล์สำหรับระบุข้อมูลโปรเจกต์และ `Library` ที่จำเป็นต้องติดตั้ง

```json filename="app/package.json"
{
  "name": "express-docker",
  "version": "1.0.0",
  "main": "index.js",
  "dependencies": {
    "express": "^4.18.2"
  }
}
```

### Application Entry Point

ไฟล์หลักสำหรับการทำงานของ `Express Server`

```bash filename="app/index.js"
const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(port, '0.0.0.0', () => {
  console.log(`Server running at http://0.0.0.0:${port}/`);
});
```

### Template Index

```bash filename="/app/index.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index</title>
</head>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Kanit:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');
    *{
        font-family: "kanit";
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body{
        height: 100vh;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    h1{
        text-align: center;
        font-size: 100px;
    }
</style>
<body>
    <h1>Hello From Express</h1>
</body>
</html>
```

## Docker Compose

<Callout type="info">
  หมายเหตุการระบุพอร์ต เนื่องจากระบบใช้การระบุตัวตนผ่าน Local DNS ของแพลตฟอร์ม
  บริการ Express รันบน Port 3000 ภายในเครือข่ายโดยตรง โดยไม่ต้องทำการ Map Port
  (Port Forwarding) ออกมายังภายนอก
</Callout>

### Upload On Platform

```yaml filename="docker-compose.yml"
version: "3.8"

services:
  express:
    image: node:18-alpine
    working_dir: /app
    volumes:
      - ./app:/app
    command: >
      sh -c "npm install && node index.js"
    restart: unless-stopped
    networks:
      - lan-net

networks:
  lan-net:
    external: true
```

<Callout type="warning">
  {" "}
  external: true คือการเข้าร่วม Network ชื่อ lan-net ที่ถูกสร้างไว้เเล้ว{" "}
</Callout>

### Full Docker Compose

```yaml filename="docker-compose.yml"
# ระบุเวอร์ชันของรูปแบบไฟล์ Docker Compose
version: "3.8"

services:
  # บริการ Web Server สำหรับรัน Node.js Express Application
  express:
    # ใช้ Node.js 18 รุ่น alpine (ขนาดเล็ก) เป็นฐาน
    image: node:18-alpine

    # กำหนดชื่อคอนเทนเนอร์เพื่อให้ง่ายต่อการจัดการ
    container_name: express-app

    # กำหนดไดเรกทอรีทำงานหลักภายใน Container
    working_dir: /app

    # เชื่อมต่อโฟลเดอร์ Source Code จากเครื่องแม่ข่ายเข้าสู่คอนเทนเนอร์
    volumes:
      - ./app:/app

    # คำสั่งรันเมื่อเริ่ม Container (ติดตั้ง npm packages และสั่งรันแอป)
    # ใช้เทคนิคนี้เพื่อลดขั้นตอนการสร้าง Dockerfile
    command: >
      sh -c "npm install && node index.js"

    # กำหนดให้คอนเทนเนอร์เริ่มทำงานใหม่อัตโนมัติเมื่อเกิดข้อผิดพลาด
    restart: unless-stopped

    # เชื่อมต่อคอนเทนเนอร์เข้ากับเครือข่ายที่กำหนด
    networks:
      - lan-net

    # เปิดพอร์ตภายในคอนเทนเนอร์สำหรับการสื่อสารภายในเครือข่าย Docker
    expose:
      - "3000"

networks:
  # กำหนดเครือข่าย Docker ที่สร้างไว้ล่วงหน้า
  lan-net:
    external: true
```
